<!--
 * @LastEditors: wudan01
 * @description: 文件描述
-->

# ts 类

#### 普通类

###### public
> 公有的，实例，当前类，子类都可以使用

###### private
> 私有，只有当前类使用

###### protected
> 受保护的，只有当前类和子类可以使用

> protected constructor 可以让类只能继承，不能直接实例化
```
class A1 {
  protected constructor() {
    console.log('123');
  }
}

// 报错
let a1 = new A1();
```
###### readonly
> 只读属性

###### static
> 静态属性

> 可以被继承

###### 综合例子
```
abstract class Animal {
    eat() {
        console.log('eat')
    }
    // 需要在子类中实现
    abstract sleep(): void
}

class Dog extends Animal {
    constructor(name: string) {
        super()
        this.name = name
        this.pri()
    }
    // 类型注解, 属性必须有初始值
    public name: string = 'dog'
    
    // 方法默认是 public 
    run() { }
    
    // 私有方法
    private pri() { }

    // 受保护方法
    protected pro() { }

    // 只读属性，不可更改
    readonly legs: number = 4

    // 静态成员 
    static food: string = 'bones'

    // 实现抽象方法
    sleep() {
        console.log('Dog sleep')
    }
}
let dog = new Dog('wangwang')
console.log(Dog.food)
dog.eat()
```

#### 抽象类
> 只能继承不能new

> 抽象类的抽象方法 必须再子类中实现

> 使用eg
```
abstract class Animal {
    eat() {
        console.log('eat')
    }
    // 需要在子类中实现
    abstract sleep(): void
}

class Dog extends Animal {
    constructor(name: string) {
        super()
    }

    // 实现抽象方法
    sleep() {
        console.log('Dog sleep')
    }
}
let dog = new Dog('wangwang')
dog.eat()
```

#### 类的链式调用
> 每次返回this
```
class Workflow {
  step1() {
    return this;
  }
  step2() {
    return this;
  }
}

new Workflow().step1().step2();

class MyFlow extends Workflow {
  next() {
    return this;
  }
}

new MyFlow().next().step1().next().step2();
```